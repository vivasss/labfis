<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulador de Vetores</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
      background: #071026;
      color: #e6eef8;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 10px;
      overflow-x: hidden;
    }

    header {
      width: 100%;
      max-width: 800px;
      padding: 12px 15px;
      background: #061226;
      border-radius: 8px 8px 0 0;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 0;
      flex-wrap: wrap;
    }

    h1 {
      font-size: clamp(16px, 4vw, 18px);
      margin: 0;
    }

    .container {
      width: 100%;
      max-width: 800px;
      background: #041224;
      border-radius: 0 0 8px 8px;
      padding: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    .controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    button {
      background: #0b3b5a;
      color: #e6eef8;
      border: 1px solid #1d5676;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: clamp(12px, 3vw, 14px);
      min-height: 36px;
      flex: 1;
      min-width: 120px;
    }

    button:hover {
      background: #0d4a6e;
    }

    .toggle-on {
      background: #1e7a3a;
    }

    .table-container {
      overflow-x: auto;
      margin-bottom: 15px;
      border: 1px solid #1d5676;
      border-radius: 6px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      min-width: 500px;
      font-size: clamp(12px, 2.5vw, 14px);
    }

    th,
    td {
      border: 1px solid #1d5676;
      padding: 6px;
      text-align: center;
    }

    th {
      background: #0b3b5a;
      font-weight: 600;
      white-space: nowrap;
    }

    input[type="number"] {
      width: 100%;
      max-width: 70px;
      background: #0b3b5a;
      color: #e6eef8;
      border: 1px solid #1d5676;
      padding: 4px;
      border-radius: 4px;
      text-align: center;
      font-size: clamp(12px, 2.5vw, 14px);
    }

    input[type="color"] {
      width: 32px;
      height: 24px;
      border: 1px solid #1d5676;
      cursor: pointer;
      border-radius: 4px;
      background: #0b3b5a;
    }

    .canvas-container {
      width: 100%;
      position: relative;
      margin-top: 15px;
      border: 1px solid #1d5676;
      border-radius: 6px;
      overflow: hidden;
    }

    #canvas {
      display: block;
      width: 100%;
      height: auto;
      background: linear-gradient(180deg, #04121b, #082033);
      touch-action: none;
    }

    #resumo {
      margin-top: 15px;
      font-weight: bold;
      background: #0b3b5a;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #1d5676;
      text-align: center;
      font-size: clamp(12px, 3vw, 14px);
    }

    .del-btn {
      background: #a83232;
      border: 1px solid #c44;
      padding: 4px 8px;
      min-height: auto;
      flex: none;
      min-width: auto;
    }

    .del-btn:hover {
      background: #c44;
    }

    .small {
      font-size: clamp(11px, 2.5vw, 12px);
      color: #bcd6ff;
    }

    .legend {
      display: flex;
      gap: 15px;
      margin-top: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .instructions {
      margin-top: 15px;
      padding: 10px;
      background: #0b3b5a;
      border-radius: 6px;
      border: 1px solid #1d5676;
      font-size: clamp(11px, 2.5vw, 13px);
    }

    .instructions p {
      margin-bottom: 5px;
    }

    .touch-hint {
      display: none;
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 10;
    }

    @media (max-width: 768px) {
      body {
        padding: 5px;
      }

      .container {
        padding: 8px;
      }

      header {
        padding: 10px;
      }

      .controls {
        gap: 5px;
      }

      button {
        padding: 8px 10px;
        min-width: 100px;
      }

      th,
      td {
        padding: 4px;
      }

      .touch-hint {
        display: block;
      }
    }

    @media (max-width: 480px) {
      button {
        min-width: 80px;
        padding: 6px 8px;
      }

      .table-container {
        font-size: 12px;
      }

      input[type="number"] {
        max-width: 60px;
        padding: 3px;
      }

      .legend {
        gap: 10px;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>Simulador de Vetores</h1>
    <div class="small">Arraste os vetores diretamente no canvas para ajustar suas posições</div>
  </header>

  <div class="container">
    <div class="controls">
      <button id="add-btn">Adicionar Vetor</button>
      <button id="clear-btn">Limpar Todos</button>
    </div>

    <div class="table-container">
      <table id="vet-table">
        <thead>
          <tr>
            <th>Vetor</th>
            <th>Magn.</th>
            <th>Ângulo (°)</th>
            <th>X</th>
            <th>Y</th>
            <th>Cor</th>
            <th>Ações</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div id="resumo">
      Resultante → X: 0.00, Y: 0.00, |R|: 0.00, θ: 0.00°
    </div>

    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <div class="touch-hint">Toque e arraste os vetores para movê-los</div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #ff4d4d;"></div>
        <span class="small">Vetores Individuais</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #6bff7a;"></div>
        <span class="small">Resultante</span>
      </div>
    </div>

    <div class="instructions">
      <p><strong>Instruções:</strong></p>
      <p>- Clique em "Adicionar Vetor" para criar novos vetores</p>
      <p>- Edite os valores diretamente na tabela ou arraste os vetores no canvas</p>
      <p>- Clique no botão "✖" para remover um vetor</p>
    </div>
  </div>

  <script>
    const tableBody = document.querySelector('#vet-table tbody');
    const addBtn = document.getElementById('add-btn');
    const clearBtn = document.getElementById('clear-btn');
    const resumo = document.getElementById('resumo');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Configuração responsiva do canvas
    function setupCanvas() {
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      const containerHeight = Math.min(containerWidth * 0.75, 450);

      canvas.width = containerWidth;
      canvas.height = containerHeight;

      // Para alta resolução em dispositivos com pixel ratio alto
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = containerWidth + 'px';
      canvas.style.height = containerHeight + 'px';
      canvas.width = containerWidth * dpr;
      canvas.height = containerHeight * dpr;
      ctx.scale(dpr, dpr);

      return { width: containerWidth, height: containerHeight };
    }

    let canvasSize = setupCanvas();
    const center = {
      x: canvasSize.width / 2,
      y: canvasSize.height / 2
    };

    let dragging = null;
    let colors = ['#ff4d4d', '#6bff7a', '#6fb8ff', '#ffd66b', '#d66bff', '#6bd6ff'];

    function toRad(d) { return d * Math.PI / 180; }
    function toDeg(r) { return r * 180 / Math.PI; }

    function recalcAndDraw() {
      // Redimensionar canvas se necessário
      canvasSize = setupCanvas();
      center.x = canvasSize.width / 2;
      center.y = canvasSize.height / 2;

      // Fundo do canvas
      const gradient = ctx.createLinearGradient(0, 0, 0, canvasSize.height);
      gradient.addColorStop(0, '#04121b');
      gradient.addColorStop(1, '#082033');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvasSize.width, canvasSize.height);

      // Grade de referência
      ctx.strokeStyle = '#1d5676';
      ctx.lineWidth = 1;
      ctx.beginPath();

      // Tamanho da grade baseado no tamanho do canvas
      const gridSize = Math.max(20, Math.min(50, canvasSize.width / 15));

      // Linhas verticais
      for (let x = center.x % gridSize; x < canvasSize.width; x += gridSize) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasSize.height);
      }

      // Linhas horizontais
      for (let y = center.y % gridSize; y < canvasSize.height; y += gridSize) {
        ctx.moveTo(0, y);
        ctx.lineTo(canvasSize.width, y);
      }
      ctx.stroke();

      // Eixos
      ctx.strokeStyle = '#3a7ba8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, center.y);
      ctx.lineTo(canvasSize.width, center.y);
      ctx.moveTo(center.x, 0);
      ctx.lineTo(center.x, canvasSize.height);
      ctx.stroke();

      // Desenhar vetores
      let sumX = 0, sumY = 0;
      Array.from(tableBody.children).forEach(tr => {
        const mag = parseFloat(tr.querySelector('.mag').value) || 0;
        const ang = parseFloat(tr.querySelector('.ang').value) || 0;
        const xIn = parseFloat(tr.querySelector('.x').value) || 0;
        const yIn = parseFloat(tr.querySelector('.y').value) || 0;
        const color = tr.querySelector('.color').value;
        const vx = xIn || mag * Math.cos(toRad(ang));
        const vy = yIn || mag * Math.sin(toRad(ang));
        sumX += vx;
        sumY += vy;
        drawArrow(center.x, center.y, center.x + vx, center.y - vy, color);
      });

      // Desenhar resultante
      if (sumX !== 0 || sumY !== 0) {
        drawArrow(center.x, center.y, center.x + sumX, center.y - sumY, '#6bff7a', 12);
      }

      // Atualizar resumo
      const Rmag = Math.hypot(sumX, sumY);
      let Rang = toDeg(Math.atan2(sumY, sumX));
      if (Rang < 0) Rang += 360;
      resumo.textContent =
        `Resultante → X: ${sumX.toFixed(2)}, ` +
        `Y: ${sumY.toFixed(2)}, ` +
        `|R|: ${Rmag.toFixed(2)}, ` +
        `θ: ${Rang.toFixed(2)}°`;
    }

    function drawArrow(x1, y1, x2, y2, color, headLen = 10) {
      const dx = x2 - x1, dy = y2 - y1;
      const ang = Math.atan2(dy, dx);

      // Ajustar tamanho da seta baseado no tamanho do canvas
      const arrowSize = Math.max(8, Math.min(12, canvasSize.width / 60));

      // Desenhar linha do vetor
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = Math.max(2, canvasSize.width / 200);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      // Desenhar cabeça da seta
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLen * Math.cos(ang - Math.PI / 6), y2 - headLen * Math.sin(ang - Math.PI / 6));
      ctx.lineTo(x2 - headLen * Math.cos(ang + Math.PI / 6), y2 - headLen * Math.sin(ang + Math.PI / 6));
      ctx.closePath();
      ctx.fill();

      // Adicionar efeito de brilho
      ctx.strokeStyle = color.replace(')', ', 0.5)').replace('rgb', 'rgba');
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function createRow() {
      const idx = tableBody.children.length + 1;
      const tr = document.createElement('tr');
      const color = colors[(idx - 1) % colors.length];

      tr.innerHTML = `
    <td>V${idx}</td>
    <td><input type="number" class="mag" step="0.1" value="50"></td>
    <td><input type="number" class="ang" step="0.1" value="${(idx - 1) * 45}"></td>
    <td><input type="number" class="x" step="0.1" value="0"></td>
    <td><input type="number" class="y" step="0.1" value="0"></td>
    <td><input type="color" class="color" value="${color}"></td>
    <td><button class="del del-btn">✖</button></td>
  `;

      tableBody.appendChild(tr);

      const [inpMag, inpAng, inpX, inpY, inpColor, delBtn] = [
        tr.querySelector('.mag'),
        tr.querySelector('.ang'),
        tr.querySelector('.x'),
        tr.querySelector('.y'),
        tr.querySelector('.color'),
        tr.querySelector('.del')
      ];

      // Inicializar valores X e Y baseados em magnitude e ângulo
      function updateXY() {
        const m = parseFloat(inpMag.value) || 0;
        const a = parseFloat(inpAng.value) || 0;
        inpX.value = (m * Math.cos(toRad(a))).toFixed(2);
        inpY.value = (m * Math.sin(toRad(a))).toFixed(2);
        recalcAndDraw();
      }

      function updateMA() {
        const x = parseFloat(inpX.value) || 0;
        const y = parseFloat(inpY.value) || 0;
        const m = Math.hypot(x, y);
        let a = toDeg(Math.atan2(y, x));
        if (a < 0) a += 360;
        inpMag.value = m.toFixed(2);
        inpAng.value = a.toFixed(2);
        recalcAndDraw();
      }

      // Event listeners
      inpMag.addEventListener('input', updateXY);
      inpAng.addEventListener('input', updateXY);
      inpX.addEventListener('input', updateMA);
      inpY.addEventListener('input', updateMA);
      inpColor.addEventListener('input', recalcAndDraw);

      delBtn.addEventListener('click', () => {
        tr.remove();
        renumberRows();
        recalcAndDraw();
      });

      // Inicializar
      updateXY();
    }

    function renumberRows() {
      Array.from(tableBody.children).forEach((tr, i) => {
        tr.children[0].textContent = `V${i + 1}`;
      });
    }

    // Função para obter coordenadas do ponteiro/toque
    function getPointerCoordinates(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;

      if (e.type.includes('touch')) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      const scaleX = canvasSize.width / rect.width;
      const scaleY = canvasSize.height / rect.height;

      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    // Interação com o canvas - Mouse e Toque
    function handlePointerStart(e) {
      e.preventDefault();
      const { x: mx, y: my } = getPointerCoordinates(e);

      // Verificar se clicou em algum vetor
      for (let tr of tableBody.children) {
        const xVal = parseFloat(tr.querySelector('.x').value) || 0;
        const yVal = parseFloat(tr.querySelector('.y').value) || 0;
        const px = center.x + xVal;
        const py = center.y - yVal;

        // Tamanho da área de toque baseado no tamanho da tela
        const touchRadius = Math.max(15, canvasSize.width / 25);

        if (Math.hypot(mx - px, my - py) < touchRadius) {
          dragging = {
            type: 'vector',
            tr,
            offset: { dx: px - mx, dy: py - my }
          };
          return;
        }
      }

      // Verificar se clicou na resultante
      let sumX = 0, sumY = 0;
      Array.from(tableBody.children).forEach(tr => {
        sumX += parseFloat(tr.querySelector('.x').value) || 0;
        sumY += parseFloat(tr.querySelector('.y').value) || 0;
      });

      const tipX = center.x + sumX;
      const tipY = center.y - sumY;

      const touchRadius = Math.max(15, canvasSize.width / 25);
      if (Math.hypot(mx - tipX, my - tipY) < touchRadius) {
        dragging = {
          type: 'result',
          offset: { dx: tipX - mx, dy: tipY - my }
        };
      }
    }

    function handlePointerMove(e) {
      if (!dragging) return;

      e.preventDefault();
      const { x: mx, y: my } = getPointerCoordinates(e);

      if (dragging.type === 'vector') {
        const { tr, offset } = dragging;
        const vx = mx + offset.dx - center.x;
        const vy = center.y - (my + offset.dy);

        tr.querySelector('.x').value = vx.toFixed(2);
        tr.querySelector('.y').value = vy.toFixed(2);

        // Disparar evento para atualizar magnitude e ângulo
        tr.querySelector('.x').dispatchEvent(new Event('input'));
        tr.querySelector('.y').dispatchEvent(new Event('input'));
      } else if (dragging.type === 'result') {
        const newX = mx + dragging.offset.dx - center.x;
        const newY = center.y - (my + dragging.offset.dy);

        let sumX = 0, sumY = 0;
        const rows = Array.from(tableBody.children);

        rows.forEach(tr => {
          sumX += parseFloat(tr.querySelector('.x').value) || 0;
          sumY += parseFloat(tr.querySelector('.y').value) || 0;
        });

        const dx = newX - sumX;
        const dy = newY - sumY;

        // Distribuir a diferença igualmente entre todos os vetores
        const shareX = dx / rows.length;
        const shareY = dy / rows.length;

        rows.forEach(tr => {
          const inpX = tr.querySelector('.x');
          const inpY = tr.querySelector('.y');

          inpX.value = (parseFloat(inpX.value) || 0 + shareX).toFixed(2);
          inpY.value = (parseFloat(inpY.value) || 0 + shareY).toFixed(2);

          inpX.dispatchEvent(new Event('input'));
          inpY.dispatchEvent(new Event('input'));
        });
      }
    }

    function handlePointerEnd() {
      dragging = null;
    }

    // Event listeners para mouse
    canvas.addEventListener('mousedown', handlePointerStart);
    canvas.addEventListener('mousemove', handlePointerMove);
    canvas.addEventListener('mouseup', handlePointerEnd);
    canvas.addEventListener('mouseleave', handlePointerEnd);

    // Event listeners para toque
    canvas.addEventListener('touchstart', handlePointerStart, { passive: false });
    canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
    canvas.addEventListener('touchend', handlePointerEnd);
    canvas.addEventListener('touchcancel', handlePointerEnd);

    // Event listeners dos botões
    addBtn.addEventListener('click', createRow);
    clearBtn.addEventListener('click', () => {
      tableBody.innerHTML = '';
      recalcAndDraw();
    });

    // Redesenhar quando a janela for redimensionada
    window.addEventListener('resize', recalcAndDraw);

    // Inicializar com dois vetores
    createRow();
    createRow();
  </script>
</body>

</html>