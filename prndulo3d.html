<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pêndulo 3D Simples</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100%;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            min-width: 280px;
            z-index: 100;
        }

        h1 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
            text-align: center;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            color: #333;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .value-display {
            display: inline-block;
            color: #667eea;
            font-weight: bold;
            margin-left: 10px;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            min-width: 280px;
            z-index: 100;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            color: #333;
            font-size: 0.9em;
        }

        .info-value {
            color: #667eea;
            font-weight: bold;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <div id="controls">
        <h1>🎯 Pêndulo 3D</h1>

        <div class="control-group">
            <label>Comprimento: <span class="value-display" id="lengthValue">3.0 m</span></label>
            <input type="range" id="length" min="1" max="5" step="0.5" value="3">
        </div>

        <div class="control-group">
            <label>Ângulo X: <span class="value-display" id="angleXValue">30°</span></label>
            <input type="range" id="angleX" min="0" max="80" step="5" value="30">
        </div>

        <div class="control-group">
            <label>Ângulo Z: <span class="value-display" id="angleZValue">0°</span></label>
            <input type="range" id="angleZ" min="0" max="80" step="5" value="0">
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="showTrail" checked>
            <label for="showTrail">Mostrar Trajetória</label>
        </div>

        <button id="resetBtn">🔄 Reiniciar</button>
    </div>

    <div id="info">
        <div class="info-item">
            <span>Velocidade:</span>
            <span class="info-value" id="velocityInfo">0.0 m/s</span>
        </div>
        <div class="info-item">
            <span>Altura:</span>
            <span class="info-value" id="heightInfo">0.0 m</span>
        </div>
        <div class="info-item">
            <span>Energia Total:</span>
            <span class="info-value" id="energyInfo">0.0 J</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Cena
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(6, 4, 6);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('container').appendChild(renderer.domElement);

        // Luz
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Grade
        const gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0xcccccc);
        gridHelper.position.y = -5;
        scene.add(gridHelper);

        // Pivô
        const pivot = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        pivot.castShadow = true;
        scene.add(pivot);

        // Corda
        const rope = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 1, 8),
            new THREE.MeshStandardMaterial({ color: 0x666666 })
        );
        scene.add(rope);

        // Massa
        const bob = new THREE.Mesh(
            new THREE.SphereGeometry(0.25, 32, 32),
            new THREE.MeshStandardMaterial({
                color: 0x667eea,
                metalness: 0.3,
                roughness: 0.4
            })
        );
        bob.castShadow = true;
        scene.add(bob);

        // Trajetória
        const trailPoints = [];
        const maxTrailPoints = 300;
        const trailGeometry = new THREE.BufferGeometry();
        const trail = new THREE.Line(
            trailGeometry,
            new THREE.LineBasicMaterial({
                color: 0x764ba2,
                transparent: true,
                opacity: 0.6
            })
        );
        scene.add(trail);

        // Parâmetros do pêndulo
        let L = 3.0;           // Comprimento
        const g = 9.8;         // Gravidade
        const mass = 1.0;      // Massa

        // Ângulos e velocidades (em radianos)
        let angleX = 30 * Math.PI / 180;
        let angleZ = 0;
        let velX = 0;
        let velZ = 0;

        let showTrail = true;
        let frameCount = 0;

        // Controles
        document.getElementById('length').addEventListener('input', (e) => {
            L = parseFloat(e.target.value);
            document.getElementById('lengthValue').textContent = L.toFixed(1) + ' m';
            resetPendulum();
        });

        document.getElementById('angleX').addEventListener('input', (e) => {
            const deg = parseFloat(e.target.value);
            angleX = deg * Math.PI / 180;
            document.getElementById('angleXValue').textContent = deg + '°';
            resetPendulum();
        });

        document.getElementById('angleZ').addEventListener('input', (e) => {
            const deg = parseFloat(e.target.value);
            angleZ = deg * Math.PI / 180;
            document.getElementById('angleZValue').textContent = deg + '°';
            resetPendulum();
        });

        document.getElementById('showTrail').addEventListener('change', (e) => {
            showTrail = e.target.checked;
            trail.visible = showTrail;
        });

        document.getElementById('resetBtn').addEventListener('click', resetPendulum);

        function resetPendulum() {
            velX = 0;
            velZ = 0;
            trailPoints.length = 0;
            frameCount = 0;
        }

        // Física simples do pêndulo 3D
        function updatePhysics(dt) {
            // Múltiplas iterações pequenas para estabilidade
            const steps = 4;
            const subDt = dt / steps;

            for (let i = 0; i < steps; i++) {
                // Aceleração devido à gravidade (aproximação para pequenos ângulos)
                const accelX = -(g / L) * Math.sin(angleX);
                const accelZ = -(g / L) * Math.sin(angleZ);

                // Atualizar velocidades
                velX += accelX * subDt;
                velZ += accelZ * subDt;

                // Pequeno amortecimento numérico para estabilidade (muito pequeno)
                velX *= 0.9999;
                velZ *= 0.9999;

                // Atualizar ângulos
                angleX += velX * subDt;
                angleZ += velZ * subDt;

                // Limitar ângulos para evitar valores extremos
                const maxAngle = 89 * Math.PI / 180;
                angleX = Math.max(-maxAngle, Math.min(maxAngle, angleX));
                angleZ = Math.max(-maxAngle, Math.min(maxAngle, angleZ));
            }
        }

        function updateVisuals() {
            // Calcular posição 3D do bob
            const x = L * Math.sin(angleX);
            const z = L * Math.sin(angleZ);
            const y = -L * Math.sqrt(Math.max(0, 1 - Math.sin(angleX) ** 2 - Math.sin(angleZ) ** 2));

            bob.position.set(x, y, z);

            // Atualizar corda
            rope.position.set(x / 2, y / 2, z / 2);
            rope.scale.y = L;
            rope.lookAt(x, y, z);
            rope.rotateX(Math.PI / 2);

            // Atualizar trajetória
            if (showTrail) {
                frameCount++;
                if (frameCount % 2 === 0) { // Adicionar ponto a cada 2 frames
                    trailPoints.push(new THREE.Vector3(x, y, z));
                    if (trailPoints.length > maxTrailPoints) {
                        trailPoints.shift();
                    }

                    if (trailPoints.length > 1) {
                        trailGeometry.setFromPoints(trailPoints);
                    }
                }
            }

            // Atualizar info
            const velocity = Math.sqrt(velX ** 2 + velZ ** 2) * L;
            const height = y + L;
            const kineticEnergy = 0.5 * mass * velocity * velocity;
            const potentialEnergy = mass * g * height;
            const totalEnergy = kineticEnergy + potentialEnergy;

            document.getElementById('velocityInfo').textContent = velocity.toFixed(2) + ' m/s';
            document.getElementById('heightInfo').textContent = height.toFixed(2) + ' m';
            document.getElementById('energyInfo').textContent = totalEnergy.toFixed(2) + ' J';
        }

        // Controle de câmera
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let cameraAngleH = Math.PI / 4;
        let cameraAngleV = Math.PI / 6;
        let cameraDistance = 10;

        function updateCamera() {
            camera.position.x = cameraDistance * Math.cos(cameraAngleV) * Math.sin(cameraAngleH);
            camera.position.y = cameraDistance * Math.sin(cameraAngleV);
            camera.position.z = cameraDistance * Math.cos(cameraAngleV) * Math.cos(cameraAngleH);
            camera.lookAt(0, 0, 0);
        }

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMouse = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouse.x;
                const deltaY = e.clientY - previousMouse.y;

                cameraAngleH -= deltaX * 0.005;
                cameraAngleV += deltaY * 0.005;
                cameraAngleV = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleV));

                updateCamera();
                previousMouse = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(4, Math.min(20, cameraDistance));
            updateCamera();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Loop principal
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            let dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Limitar dt para evitar saltos grandes
            dt = Math.min(dt, 0.02);

            updatePhysics(dt);
            updateVisuals();

            renderer.render(scene, camera);
        }

        updateCamera();
        animate();
    </script>
</body>

</html>